[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/GqrHw_cP)
# Macalester College Degree Helper

We wrote a program where a user inputs all of the Macalester courses they have taken and the program outputs which area(s) of study (majors, minors, and concentrations) they are closest to completing (by number of courses) and any other requirements for that area of study (e.g. must study away), as well as the number of courses left to take for every other area of study. We decided on this idea for our final project because we realized that there is no Macalester resource that will give this data to a student, the only way they can see how close they are to finishing an area of study is by specifically indicating that area on DegreeWorks. Our program allows the user to see how close they are to finishing areas that they may have never thought about before. One thing to note about our program is that it gives the area with the absolute fewest remaining courses, even if the user has not taken 

Our program has three classes: AreasOfStudy, DegreeHelper, and DegreeComparator. The AreasOfStudy class is used to make the ArrayList of all courses and the HashMap of each area of study’s requirements. The DegreeHelper class uses a Scanner to get the courses the user inputs and it uses the getAllCourses getter method from an AreasOfStudy object to check that the user’s courses are in the list of all courses. This class also houses our main method. The main method makes a new DegreeComparator object with the ArrayList of the user’s courses as the parameter. The DegreeComparator class compares each of the user’s courses to the required courses in each area of study (from the HashMap in the AreasOfStudy class, retrieved with a getter method) in order to give the user the area of study they are closest finishing.

Our first and most prevalent data structure is the Map. We used maps in multiple cases including sourcing class and area of study requirements data from our csv files and comparing the user’s taken-classes with the requirements for each area of study. Specifically, we used a HashMap implementation because it has fast lookups through its hashing function. This preset implementation also results in no collisions which would have been an issue if we tried to implement our own map. The put and get methods for HashMaps have average O(1) time complexity which is another benefit of hashing. When parsing through the different areas of study and their requirements, we wanted a data structure with easy searchability so that when comparing we could easily get data for specific needs. For this reason, we used a map with keys being different areas of study represented through strings and the values being maps themselves. These maps have keys being strings for distinct classes and values being strings denoting a classes spot in the requirements. During the comparison process we used two maps. While looping through the different areas of study we used a map to show how far along the user was for each: keys being the different requirement groups of that study as strings and values being integers for how many classes of that group are complete. This map would get rewritten for every area of study compared in the loop. The second map in the comparison process used this data gathered from those temporary areas of study specific maps to determine how many more classes the user has to take for every area of study. The keys are areas of study as strings and the values were integers. This map was parsed in order to print out the report showing information about progress on every area of study.

We used lists in order to house the user’s inputted classes. We would take this list, using ArrayList implementation, and use it to compare the classes the user had already taken to the requirements for every area of study. Also, during the comparison process when multiple areas of study are all the closest ones for the respective user, they are combined into an ArrayList for the printing of the progress report. We used lists for these two situations because we needed to continually add to it without knowing the total size: something we would have had to contend with using an array. We used an array implementation of a list instead of a linked-list one because ArrayList has O(1) lookups and a linked list has O(n) lookups. Also, the order of elements didn’t matter to us so a linked list was not necessary.

